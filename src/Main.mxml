<?xml version="1.0" encoding="utf-8"?>
<mx:Application
	xmlns:mx="http://www.adobe.com/2006/mxml"
	xmlns:svvitch="*"
	creationComplete="init()"
	verticalScrollPolicy="off"
	frameRate="30">
	<mx:Style>
		global{
			modal-transparency: 0.8;
			modal-transparency-blur: 0;
			modal-transparency-color: #000000;
			modal-transparency-duration: 0;
		}

		Application {
			font-size: 13px;
			color: #cccccc;
			background-color: #333333;
			padding-top: 20;
			padding-left: 4;
			padding-bottom: 4;
			padding-right: 4;
		}

		ApplicationControlBar {
			font-weight: bold;
		}

		Panel {
			color: #cccccc;
			font-size: 13px;
			background-color: #333333;
			background-alpha: 0.8;
			border-style: solid;
			border-color: #999999;
			border-thickness: 1;
			border-thickness-left: 4;
			border-thickness-right: 4;
			border-alpha: 0.5;
			title-style-name: "panelTitle";
		}

		.panelTitle {
			font-weight: bold;
		}

		TitleWindow {
			background-color: #333333;
		}

		Form {
			padding-top: 0;
			padding-left: 0;
			padding-bottom: 0;
			padding-right: 0;
		}

		TextInput {
			fontFamily: monospace;
			border-style: none;
			background-color: #111111;
			background-alpha: 0.5;
			color: #cccccc;
		}

		TextArea {
			fontFamily: monospace;
			border-style: none;
			background-color: #111111;
			background-alpha: 0.5;
			color: #cccccc;
		}

		.comboDropdown {
			background-color: #333333;
			background-alpha: 0.6;
			color: #cccccc;
		}

		TabNavigator {
			color: #cccccc;
			background-color: #333333;
			selected-tab-text-style-name: "selectedTab";
		}

		.selectedTab {
		   text-roll-over-color: #ffffff;
		}

		List {
			background-color: #000000;
			background-alpha: 0.9;
			border-color: #666666;
			padding-right: 2;
			dropIndicatorSkin: ClassReference("skins.ListDropIndicator");
		}

		VScrollBar {
			color: #cccccc;
			cornerRadius: 0;
			border-color: #000000;
			track-colors: #111111, #111111;
			fill-colors: #333333, #333333;
			fill-alphas: 1,1;
			highlight-alphas: 0, 0;
		}

		HScrollBar {
			cornerRadius: 0;
		}

		DataGrid {
			background-color: #000000;
			background-alpha: 0.9;
			color: #cccccc;
			header-colors: #555555, #222222;
			alternating-item-colors: #161616, #111111;
			border-color: #333333;
			vertical-grid-line-color: #333333;
			header-separator-skin: Embed(source="../images/transparent.png");
		}

		TileList {
			background-color: #000000;
			background-alpha: 0.9;
			border-color: #666666;
			padding-left: 2;
			padding-right: 2;
		}

		Button {
			color: #cccccc;
			text-selected-color: #333333;
		}

		.btnTransitionSlide {
			upSkin: Embed(source="../images/transition_slide.png");
			overSkin: Embed(source="../images/transition_slide.png");
			downSkin: Embed(source="../images/transition_slide.png");
			disabledSkin: Embed(source="../images/transition_slide.png");
		}
		.btnTransitionDissolve {
			upSkin: Embed(source="../images/transition_dissolve.png");
			overSkin: Embed(source="../images/transition_dissolve.png");
			downSkin: Embed(source="../images/transition_dissolve.png");
			disabledSkin: Embed(source="../images/transition_dissolve.png");
		}

		.titleText {
			color: #33cc33;
			font-size: 12px;
			font-weight: bold;
			padding-top: 8;
		}

		.displayText {
			color: #6699ff;
			font-size: 24px;
			font-weight: bold;
		}

		.stopWatchText {
			color: #cccccc;
			font-size: 20px;
			font-weight: bold;
		}

		.statusNormal {
			color: #33cc33;
			font-size: 10px;
			font-weight: bold;
		}

		.statusWarning {
			color: #cc3333;
			font-size: 10px;
			font-weight: bold;
		}

		.footerText {
			color: #cccccc;
			font-size: 11px;
			font-weight: bold;
			text-align: center;
		}

	</mx:Style>
	<mx:Number id="selected">{getSelectedIndex(_displays)}</mx:Number><!-- radioButtonの選択行 -->
	<mx:ApplicationControlBar id="titleBar" dock="true">
		<mx:Image id="appLogo" source="{_logo}" width="32" height="32" />
		<mx:Label id="appTitle" text="airSvvitch" />
		<mx:Label id="editedSign" text="" width="100%" />
		<mx:ToggleButtonBar id="navigation">
			<mx:dataProvider>
				<mx:String>ディスプレイ選択</mx:String>
				<mx:String>操作する</mx:String>
			</mx:dataProvider>
		</mx:ToggleButtonBar>
		<mx:Spacer width="100%"/>
		<mx:Button id="closeButton" label="X" click="onClose();" />			
	</mx:ApplicationControlBar>
	<mx:ViewStack selectedIndex="{navigation.selectedIndex}" change="changeView(event)" width="100%" height="100%" creationPolicy="all" verticalScrollPolicy="off">
		<mx:VBox width="100%" height="100%" horizontalAlign="center">
			<mx:Form id="displayConfigForm" width="1000">
				<mx:FormItem label="ディスプレイ名" required="true" >
					<mx:TextInput id="displayName" />
				</mx:FormItem>
				<mx:FormItem label="IPアドレス" required="true">
					<mx:TextInput id="displayAddress" restrict="0-9." maxChars="15" />
				</mx:FormItem>
				<mx:FormItem label="説明" width="100%">
					<mx:TextArea id="displayDescription" width="100%" />
				</mx:FormItem>
				<mx:HBox width="100%" horizontalAlign="right">
					<mx:Button label="add" click="addDisplay()" />
				</mx:HBox>
				<mx:Spacer height="10"/>
				<mx:DataGrid id="displayGrid" width="100%" height="300" dataProvider="{_displays.display}"
					verticalScrollPolicy="on" sortableColumns="false"
					editable="true" itemEditBeginning="onDisplayEditBeginning(event)">
					<mx:columns>
						<mx:Array>
							<mx:DataGridColumn headerText="編集" width="50" dataField="edit" textAlign="center"
								itemRenderer="RadioButtonRenderer" editorDataField="selected" rendererIsEditor="true" />
							<mx:DataGridColumn headerText="出力" width="50" dataField="out"
								itemRenderer="CheckBoxRenderer" editorDataField="selectedValue" rendererIsEditor="true" />
							<mx:DataGridColumn headerText="状態" width="50" dataField="status" editable="false" textAlign="center" />
							<mx:DataGridColumn headerText="ディスプレイ名" width="120" dataField="name" />
							<mx:DataGridColumn headerText="IPアドレス" width="120" dataField="address" />
							<mx:DataGridColumn headerText="説明" dataField="description" />
						</mx:Array>
					</mx:columns>
				</mx:DataGrid>
				<mx:HBox width="100%" horizontalAlign="right">
					<mx:Button label="font" click="sendFile()" />
					<mx:Button label="sync" click="syncWorkspace()" />
					<mx:Button label="export" click="exportWorkspace()" />
					<mx:Button label="delete" click="deleteDisplayItem()" />
				</mx:HBox>
			</mx:Form>
		</mx:VBox>
		<mx:HBox width="100%" height="100%">
			<mx:VBox>
				<mx:Canvas id="preview" backgroundColor="#000000" width="240" height="180">
				</mx:Canvas>
				<mx:HBox width="240" verticalAlign="middle">
					<mx:HSlider id="brightness" width="100%" minimum="0" maximum="100" tickInterval="10" snapInterval="1" value="{_brightness}" change="changeBrightness(event)" />
					<mx:Image source="{_iconBrightness}" width="24" height="24" toolTip="輝度設定" />
				</mx:HBox>
				<mx:VBox width="240" backgroundColor="#000000" paddingLeft="1" verticalGap="1">
					<mx:Label text="再生中コンテンツ:" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:Label text="{_currentPlaylist}" color="#cccccc" width="235" paddingLeft="5" />
					<mx:Label text="{_currentContent}" color="#cccccc" width="235" textAlign="right" paddingLeft="10" />									
					<mx:Label text="残り時間 {_timeRemain}(概算)" color="#cccccc" width="235" textAlign="right" paddingLeft="10" />						
					<mx:Label text="次のコンテンツ:" paddingTop="8" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:Label text="{_nextPlaylist}" color="#cccccc" width="235" paddingLeft="5" />
					<mx:Label text="{_nextContent}" color="#cccccc" width="235" textAlign="right" paddingLeft="10" />
					<mx:Label text="トランジション:" paddingTop="8" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:ToggleButtonBar id="transition" horizontalGap="1" paddingTop="2" >
						<mx:dataProvider>
							<mx:Object toolTip="OFF" />
							<mx:Object toolTip="スライド" label="Slide" />
							<mx:Object toolTip="ディゾルブ" label="Dissolve" />
						</mx:dataProvider>
					</mx:ToggleButtonBar>
					<mx:Label text="遷移アクション:" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:ToggleButtonBar id="action" horizontalGap="1" paddingTop="2" >
						<mx:dataProvider>
							<mx:Object toolTip="次へ" />
							<mx:Object toolTip="最終フレームで停止" label="St" />
							<mx:Object toolTip="最終フレームで停止＆次の準備" label="StP" />
							<mx:Object toolTip="次の準備ができるまで停止" label="Wa" />
							<mx:Object toolTip="プレイリスト移動" label="Ju" />
						</mx:dataProvider>
					</mx:ToggleButtonBar>
				</mx:VBox>
				<mx:VBox width="240" backgroundColor="#000000" paddingLeft="1" verticalGap="2">
					<mx:Label text="ストップウォッチ:" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:HBox width="235" verticalAlign="middle" horizontalGap="1" >
						<mx:Label id="watchTime" text="00:00:00" textAlign="center" width="100%" styleName="stopWatchText" />
						<mx:Button id="watchButton" label="開始" click="actionStopWatch(event)" />
						<mx:Button id="watchResetButton" label="ﾘｾｯﾄ" click="resetStopWatch()" />
					</mx:HBox>
				</mx:VBox>
				<mx:VBox width="240" backgroundColor="#000000" paddingLeft="1" verticalGap="2">
					<mx:Label text="ディスプレイ:" styleName="titleText" />
					<mx:HRule width="235" alpha="0.5" />
					<mx:Label text="{_stageName}" styleName="displayText" width="235" textAlign="center" paddingLeft="10" />
				</mx:VBox>
			</mx:VBox>
			<mx:VBox>
				<mx:HBox>
					<mx:VBox>
						<mx:TabNavigator id="sourceTab" backgroundColor="#333333" paddingBottom="0">
							<mx:VBox label="プレイリスト" paddingLeft="4" paddingRight="4" paddingBottom="4">
								<mx:HBox width="100%" verticalAlign="middle">
									<mx:Image source="{_iconXmag}" width="16" height="16" toolTip="プレイリスト名で絞込み検索" />
									<mx:TextInput id="findPlaylist" text="" width="120" change="filterPlaylist(event)" />								
									<mx:Spacer width="100%"/>
									<mx:Button id="addPlaylistButton" label="＋" click="addPlaylist(event)"  />
									<mx:Button id="deletePlaylistButton" label="－" click="deletePlaylist(event)" />
								</mx:HBox>
								<svvitch:PlaylistSelector id="playlistSelector" width="250" height="572" change="changePlaylist()" />
							</mx:VBox>
							<mx:VBox id="mediaTab" label="メディア" paddingLeft="4" paddingRight="4" paddingBottom="4">
								<mx:HBox width="100%" verticalAlign="middle">
									<mx:Image source="{_iconXmag}" width="16" height="16" toolTip="メディア名で絞込み検索" />
									<mx:TextInput id="findMedia" text="" width="120" change="filterMedia(event)" />								
									<mx:Spacer width="100%"/>
									<mx:Button id="addMediaButton" label="＋" click="addMedia(event)" />
									<mx:Button id="deleteMediaButton" label="－" click="deleteMedia(event)" />
								</mx:HBox>
								<svvitch:MediaSelector id="mediaSelector" width="250" height="572" />								
							</mx:VBox>
						</mx:TabNavigator>
					</mx:VBox>
					<mx:VBox>
						<mx:HBox width="100%">
							<mx:Button id="editMode" click="toggleEditMode(event)" />
							<mx:Button id="saveButton" label="SAVE" click="saveWorkspace(event);" />	
							<mx:VBox width="270" backgroundColor="#000000" paddingLeft="1" verticalGap="1">
								<mx:HBox>
									<mx:Label text="準備コンテンツ:" styleName="titleText" paddingTop="4" />
									<mx:Label text="{_preparedPlaylist}" color="#cccccc" width="160" paddingTop="4" paddingLeft="1" />
								</mx:HBox>
								<mx:Label text="{_preparedContent}" color="#cccccc" width="265" textAlign="right" paddingLeft="10" />
							</mx:VBox>
							<mx:Button id="swButton" label="SVVITCH" click="switchContent()" />	
						</mx:HBox>
						<mx:TabNavigator id="detailTab" backgroundColor="#333333"  paddingBottom="0">
							<mx:VBox width="100%" label="プレイリスト編成" paddingLeft="4" paddingRight="4" paddingBottom="4">
								<mx:HBox width="100%">
									<mx:ColorPicker id="colorPicker" editable="true" change="changeColor(event)" />
									<mx:TextInput id="playlistName" text="" change="changePlaylistName(event)" width="300" />
								</mx:HBox>
								<mx:HBox width="100%">
									<mx:TextArea id="playlistText" width="100%" height="80" editable="false" maxChars="1000" />
									<mx:VBox height="100%">
										<mx:Spacer height="100%" />
										<mx:Button id="textUpdateButton" label="TEXT" click="updatePlaylistText(event)"
											toolTip="文字テロップを更新" visible="false" />
									</mx:VBox>
								</mx:HBox>
								<svvitch:PlaylistEditor id="playlistEditor" width="480" height="242" change="selectContent()" />
								<mx:HBox width="100%">
									<mx:Spacer width="100%"/>
									<mx:Button id="deletePlaylistItemButton" label="－" click="deletePlaylistItem(event)" />
								</mx:HBox>
							</mx:VBox>
							<mx:VBox id="timelineTab" width="100%" label="タイムライン" paddingLeft="4" paddingRight="4" paddingBottom="4">
								<svvitch:ScheduleEditor id="scheduleEditor" width="480" height="356" />
								<mx:HBox width="100%">
									<mx:Spacer width="100%"/>
									<mx:Button id="addScheduleItemButton" label="＋" click="addScheduleItem(event)" />
									<mx:Button id="deleteScheduleItemButton" label="－" click="deleteScheduleItem(event)" />
								</mx:HBox>
							</mx:VBox>
						</mx:TabNavigator>
						<mx:Panel title="ショートカット" width="100%">
							<svvitch:ShortcutList id="shortcutList" width="480" height="100" />
							<mx:HBox width="100%">
								<mx:Spacer width="100%"/>
								<mx:Button id="deleteShortcutButton" label="－" click="deleteShorcut(event)" />
								<mx:Button id="returnButton" label="復帰" click="returnPlaylist(event)" enabled="false" />
							</mx:HBox>
						</mx:Panel>
					</mx:VBox>
				</mx:HBox>
			</mx:VBox>
		</mx:HBox>
	</mx:ViewStack>
	<mx:HRule width="100%" alpha="0.5" />
	<mx:HBox width="100%" backgroundColor="#000000" verticalGap="0" >
		<mx:Label id="statusText" width="1000" text="　" styleName="statusNormal" />					
	</mx:HBox>
	<!--
	<mx:Label width="100%" text="copyright(c)2009-{_year} {_copyright} allrights reserved." styleName="footerText" />
	-->
	<!-- コード -->
	<mx:Script><![CDATA[
		import flash.display.Sprite;
		import flash.events.Event;
		import flash.events.EventDispatcher;
		import flash.events.IOErrorEvent;
		import flash.events.MouseEvent;
		import flash.events.TimerEvent;
		import flash.events.KeyboardEvent;
		import flash.filesystem.File;
		import flash.net.URLLoader;  
		import flash.net.URLRequest;  
		import flash.net.URLVariables;
		import flash.utils.getTimer;
		import flash.utils.Timer;
		import flash.system.Capabilities;
		import mx.controls.Image;
		import mx.controls.Alert;
		import mx.controls.Button;
		import mx.events.CloseEvent;
		import mx.events.DragEvent;
		import mx.events.FlexEvent;
		import mx.collections.ArrayCollection;
		import mx.events.CollectionEvent;
		import mx.events.DataGridEvent;
		import mx.core.IUIComponent;
		import mx.core.IFlexDisplayObject;
		import mx.managers.DragManager;
		import mx.managers.PopUpManager;

		import com.adobe.serialization.json.JSON;  
		import com.rails2u.net.URLLoaderWithTimeout;

		[Embed(source="../images/switch_logo.png")]
        [Bindable] private var _logo:Class;

		[Embed(source="../images/brightness.png")]
        [Bindable] private var _iconBrightness:Class;

		[Embed(source="../images/transition_slide.png")]
        [Bindable] private var _iconTransitionSlide:Class;
		[Embed(source="../images/transition_dissolve.png")]
        [Bindable] private var _iconTransitionDissolve:Class;

		[Embed(source="../images/Crystal_Clear_app_xmag.png")]
        [Bindable] private var _iconXmag:Class;

		[Embed(source="../images/decrypted.png")]
        private var _unlockIcon:Class;
		[Embed(source="../images/encrypted.png")]
        private var _lockIcon:Class;

		// (xp) C:\Documents and Settings\username\Application Data\appId\Local Store
		// (vista) C:\Users\username\AppData\Roaming\appId\Local Store
		private var _workDir:File = File.applicationStorageDirectory;
		//private const DISPLAY_FILE:File = new File("app-storage:/displays.xml"); 

		[Bindable] public var _year:int = new Date().getFullYear();
		[Bindable] public var _copyright:String = "";
		[Bindable] public var _displays:XML = <displays />;
		[Bindable] public var _workspace:XML = <workspace />;
		[Bindable] public var _playlist:XML = <playlist />;
		[Bindable] public var _stageName:String = "";
		[Bindable] public var _currentPlaylist:String = "";
		[Bindable] public var _currentContent:String = "";
		[Bindable] public var _timeRemain:String = "";
		[Bindable] public var _nextPlaylist:String = "";
		[Bindable] public var _nextContent:String = "";
		[Bindable] public var _preparedPlaylist:String = "";
		private var _preparedPlaylistID:String = null;
		[Bindable] public var _preparedContent:String = "";
		[Bindable] public var _brightness:int = 50;
		private var _signature:String;
		private var _statusCount:int = 0;
		private var _action:String;
		private var _transition:String;
		private var _delayedUpdate:String;

		private var _oldDataGridEvent:DataGridEvent;

		private var _monitorDisplay:int = 0;
		private var _previewTimer:Timer = null;
		private var _statusTimer:Timer = null;
		private var _mediaSyncronizer:MediaSyncronizer = null;

		private var _editedDisplay:Boolean = false;

		private var _editable:Boolean = false;
		private var _uploader:UploadProgressBar;

		private var _shadowFilter:DropShadowFilter;		

		private var _stopWatchTimer:Timer = null;
		//private var _activeStopWatch:Boolean = false;
		private var _watchLast:Number = 0;
		private var _watchElapsed:Number = 0;

		private var _playingPlaylistID:String = null;
		private var _playingIndex:int = -0;
		private var _returnPlaylistID:String = null;
		private var _returnIndex:int = -0;

		private var _alert:Alert = null;

		// 初期化
		private final function init():void {
			trace("os: " + Capabilities.os);
			var screenBounds:Rectangle = Screen.mainScreen.bounds; 
			systemManager.stage.nativeWindow.x = (screenBounds.width - systemManager.stage.nativeWindow.width) / 2; 
			systemManager.stage.nativeWindow.y = (screenBounds.height - systemManager.stage.nativeWindow.height) / 2; 
			systemManager.stage.nativeWindow.visible = true;
			initConfig();
			_shadowFilter = new DropShadowFilter();
			_shadowFilter.color = 0x000000;
			_shadowFilter.alpha = 0.4;
			_shadowFilter.blurX = 5;
			_shadowFilter.blurY = 5;
			_shadowFilter.distance = 5;
			addShadow(appLogo);
			addShadow(appTitle);

			titleBar.addEventListener(MouseEvent.MOUSE_DOWN, moveApplication);
			// フルスクリーンの指定
			// systemManager.stage.displayState = StageDisplayState.FULL_SCREEN_INTERACTIVE;

			// テンポラリのクリア
			var temp:File = _workDir.resolvePath("temp/");
			if (temp.exists) {
				var files:Array = temp.getDirectoryListing();
				for each(var file:* in files) {
					if (file.isDirectory) {
						file.deleteDirectory(true);
					} else {
						file.deleteFile();
					}
					trace("delete " + file.nativePath);
				}				
			}
			addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			addEventListener(OperationStatusEvent.OPERATION_STATUS, function(event:OperationStatusEvent):void {
				updateStatusText(event.text);
			});
			addEventListener(KeyboardEvent.KEY_UP, function(event:KeyboardEvent):void {
				if (!_editable && event.controlKey) {
					//trace('key:' + event.keyCode);
					switch (event.keyCode) {
					case 13: // Enterキー
						switchContent();
						break;
					}
				}
			});
			playlistSelector.addEventListener(KeyboardEvent.KEY_UP, function(event:KeyboardEvent):void {
				switch (event.keyCode) {
				case 46: // Deleteキー
					if (_editable) deletePlaylist(event);
				}
			});
			mediaSelector.addEventListener(OperationStatusEvent.OPERATION_STATUS, function(event:OperationStatusEvent):void {
				updateStatusText(event.text);
			});
			mediaSelector.addEventListener(KeyboardEvent.KEY_UP, function(event:KeyboardEvent):void {
				switch (event.keyCode) {
				case 46: // Deleteキー
					if (_editable) deleteMedia(event);
				}
			});
			playlistEditor.addEventListener(PlaylistItemEvent.ADD_PLAYLIST_ITEM, function(event:PlaylistItemEvent):void {
				setTextEditMode();
			});
			playlistEditor.addEventListener(KeyboardEvent.KEY_UP, function(event:KeyboardEvent):void {
				switch (event.keyCode) {
				case 46: // Deleteキー
					if (_editable) deletePlaylistItem(event);
				}
			});
			initDisplayConfig();
		}

		private final function initConfig():void {
			var configXML:File = new File("app:/config.xml");
			if (configXML.exists) {
				var fs:FileStream = new FileStream();
				try {
					fs.open(configXML, FileMode.READ);
					var text:String = fs.readUTFBytes(fs.bytesAvailable);
					var xml:XML = XML(text);
					_workDir = new File(xml.work.text());
					if (!_workDir.exists) _workDir.createDirectory();
				} catch (error:Error) {
					trace("<Error> " + error.message);
				} finally {
					fs.close();		
				}
			}
			trace("work directory: " + _workDir.nativePath);
		}

		public final function editedWorkspace(event:Event):void {
			trace('edited');
			_editedDisplay = true;
			editedSign.text = "*";
			saveButton.setStyle("fillColors", [0xe66666, 0xff6666]);
		}

		private final function uneditedWorkspace():void {
			_editedDisplay = false;
			editedSign.text = "";
			saveButton.setStyle("fillColors", [0xe6eeee, 0xffffff]);
		}

		private final function addShadow(comp:DisplayObject):void {
			comp.filters = [_shadowFilter];
		}

		private final function moveApplication(event:Event):void {
			systemManager.stage.nativeWindow.startMove();
		}

		private final function updateStatusText(s:String):void {
			if (s.indexOf("!") == 0) {
				s = s.substr(1);
				statusText.styleName = "statusWarning";
			} else {
				statusText.styleName = "statusNormal";
			}
			statusText.text = s;
		}

		/** トグルボタンによるviewの変更 */
		private final function changeView(event:Event):void {
			trace("change: " + _editedDisplay);
			var i:int = navigation.selectedIndex;
			if (i == 0 && _mediaSyncronizer != null && _mediaSyncronizer.running()) {
				Alert.show("メディアを同期中ですので少々お待ちください");
				stopPreview();
				stopStatus();
				navigation.selectedIndex = 1;

			} else if (_editedDisplay) {
				if (i == 0) {
					// 1→0への遷移の時、変更の有無を確認
					Alert.show("変更されていますが、保存せずに移動してよろしいですか？", "保存の確認", Alert.YES | Alert.NO, this, function(event:CloseEvent):void {
						if (event.detail == Alert.YES) {
							uneditedWorkspace();
							initDisplayConfig();
						} else {
							stopPreview();
							stopStatus();
							navigation.selectedIndex = 1;
						}
					});
				}

			} else {
				trace('view: ' + navigation.selectedIndex);
				switch (navigation.selectedIndex) {
					case 0:
						// ディスプレイ設定
						initDisplayConfig();
						break;
					case 1:
						// 操作
						initPlayOperation();
						break;
				}				
			}
		}

		/** ディスプレイ設定の初期化 */
		private final function initDisplayConfig():void {
			dispatchEvent(new OperationStatusEvent(' '));
			stopPreview();
			stopStatus();
			if (_displays.display.length() == 0) {
				var fs:FileStream = new FileStream();
				try {
					var displayFile:File = _workDir.resolvePath("displays.xml");
					fs.open(displayFile, FileMode.READ);
					var xml:String = fs.readUTFBytes(fs.bytesAvailable);
					_displays = XML(xml);
				} catch (error:Error) {
					trace("<Error> " + error.message);
				} finally {
					fs.close();		
				}
				_monitorDisplay = 0;
				checkDisplayStatus();
				trace('load displays: ' + _displays.display.length());
			}
		}

		// ディスプレイステータスのチェック
		private final function checkDisplayStatus():void {
			if (_displays.display.length() > 0) {
				var display:XML = _displays.display[_monitorDisplay];
				display.status = ' ';
				var loader:URLLoader = new URLLoader();
				loader.addEventListener(Event.COMPLETE, updateDisplayStatus);
				loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
					trace("'/get/display-status' no result: " + _monitorDisplay);
					//var display:XML = _displays.display[_monitorDisplay];
					//dispatchEvent(new OperationStatusEvent("![" + display.name + "]に接続できません"));
					try {
						var display:XML = _displays.display[_monitorDisplay];
						display.status = '-';
						_monitorDisplay = (_monitorDisplay + 1) % _displays.display.length();
						startDisplayCheck();
					} catch (error:Error) {
						trace("<Error> " + error.message);
					}
				});
				if (SwitchUtils.isLocalMode(display)) {
					display.status = 'OK';
					startDisplayCheck();
				} else {
					var request:URLRequest = new URLRequest(SwitchUtils.baseURL(display.address) + "/get/display-status");
					request.cacheResponse = false;
					request.useCache = false;
					loader.load(request);	
				}
			}
		}

		// ディスプレイチェックの開始
		private final function startDisplayCheck():void {
			var t:Timer = new Timer(1000, 1);
			t.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
				checkDisplayStatus();
			});
			t.start();			
		}

		/** ディスプレイステータスの更新 */
		private final function updateDisplayStatus(event:Event):void {
			//trace('remote display status');
			var loader:URLLoader = URLLoader(event.currentTarget);
			var json:String = loader.data;
			try {
				var display:XML = _displays.display[_monitorDisplay];
				display.status = 'OK';
				var status:Object = JSON.decode(json);
				var remoteCopy:String = status['remote-copy'];
				if (remoteCopy) {
					if (remoteCopy == "1") {
						dispatchEvent(new OperationStatusEvent("[" + display.name + "]同期処理を開始しました"));
					} else if (remoteCopy == "3") {
						dispatchEvent(new OperationStatusEvent("[" + display.name + "]同期中..."));
					} else if (remoteCopy.indexOf("3") == 0) {
						dispatchEvent(new OperationStatusEvent("[" + display.name + "]" + remoteCopy.substr(2) + " 同期中..."));
					} else if (remoteCopy == "10") {
						dispatchEvent(new OperationStatusEvent("[" + display.name + "]同期処理が終了しました"));
						var t:Timer = new Timer(5000, 1);
						t.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
							var request:URLRequest = new URLRequest(SwitchUtils.baseURL(display.address) + "/set/status");
							request.cacheResponse = false;
							request.useCache = false;
							request.method = URLRequestMethod.POST;
							var params:URLVariables = new URLVariables();
							params.n = "remote-copy";
							params.v = "";
							request.data = params;
							sendToURL(request);
							trace("reset remote-copy");				
						});
						t.start();			
					}
				}
				if (status['delayed-update'] != _delayedUpdate) {
					_delayedUpdate = status['delayed-update'];
					if (_delayedUpdate) dispatchEvent(new OperationStatusEvent("!" + "[" + display.name + "]" + _delayedUpdate + "が使用中のため、停止してから更新されます"));
				}
				if (_statusCount == 0) {
					_delayedUpdate = "";
				}
			} catch (error:Error) {
				trace(error.message + ":" + json);
			}
			_monitorDisplay = (_monitorDisplay + 1) % _displays.display.length();
			_statusCount = (_statusCount + 1) % 10;
			startDisplayCheck();
		}

		/** 編集ディスプレイの取得 */
		private final function getEditDisplay():XML {
			return SwitchUtils.getEditDisplay(_displays);
		}

		/** ディスプレイへのベースURL取得 */
		private final function baseURL():String {
			return SwitchUtils.selectedDisplayToBaseURL(_displays);
		}

		private final function isLocalMode():Boolean {
			var display:XML = getEditDisplay();
			return SwitchUtils.isLocalMode(display);
		}

		/** DataGrid選択Index取得処理 */
		private final function getSelectedIndex(displays:XML):int {
			var len:int = displays.display.length();
			for (var i:int = 0; i < len; i++) {
				if (displays.display[i].edit == 'true') {
					return i;
				}
			}
			return -1;
		}

		/** ディスプレイ追加 */
		private final function addDisplay():void {
			if (displayName.text.length == 0) {
				Alert.show("ディスプレイ名を入力してください");
				return;
			}
			if (displayAddress.text.length == 0) {
				Alert.show("IPアドレスを入力してください");
				return;
			}
			var display:XML = <display />;
			display.edit = "false";
			display.out = "false";
			display.name = displayName.text;
			display.address = displayAddress.text;
			display.description = displayDescription.text;
			_displays.appendChild(display);
			trace('display: ' + _displays.display.length);
			if ( _displays.display.length() > 0) {
				startDisplayCheck();
			}
		}

		/** ファイル送信 */
		private final function sendFile():void {
			var i:int = displayGrid.selectedIndex;
			if (i != -1) {
				var file:File = File.documentsDirectory;
				file.addEventListener(Event.SELECT, function(event:Event):void {
					var f:File = event.target as File;
					var sender:FileSender = new FileSender(_displays.display[i].address, f);
					sender.addEventListener(OperationStatusEvent.OPERATION_STATUS, function(event:OperationStatusEvent):void {
						updateStatusText(event.text);
					});
					sender.exec();
				});
				try {
					var filter:FileFilter = new FileFilter("フォントファイル(.ttf/.ttc)", "*.ttf;*.ttc");
					var allFilter:FileFilter = new FileFilter("全て", "*.*");
					file.browseForOpen("送信したいファイルを選択してください。", [filter, allFilter]);
				} catch (error:Error) {
					trace("Failed:", error.message);
				}
			} else {
				Alert.show("送信先のディスプレイを選択してください");
			}
		}

		/** 同期処理 */
		private final function syncWorkspace():void {
			var edit:String = "";
			var editIP:String = "";
			var outDisplays:Array = new Array();
			for (var i:int = 0; i < _displays.display.length(); i++) {
				if (_displays.display[i].edit == 'true') {
					edit = _displays.display[i].name;
				} else if (_displays.display[i].out == 'true') {
					outDisplays.push(_displays.display[i].name);
				}
			}
			if (edit.length > 0 && outDisplays.length > 0) {
				var text:String = "[" + edit + "] -> [" + outDisplays.join(" / ") + "]\n同期してよろしいですか？";
				Alert.show(text, "同期処理の確認", Alert.YES | Alert.NO, this, function(event:CloseEvent):void {
					if (event.detail == Alert.YES) {
						copyWorkspace();
					}
				});
			} else {
				Alert.show("編集/出力ディスプレイを選択してください");				
			}
		}

		/** エクスポート処理 */
		private final function exportWorkspace():void {
			var i:int = displayGrid.selectedIndex;
			if (i != -1) {
				var directory:File = File.documentsDirectory;
				directory.addEventListener(Event.SELECT, function(event:Event):void {
					var dir:File = event.target as File;
					var dst:File = new File(dir.nativePath + "/switch-datas");
					var src:File = _workDir.resolvePath("datas/" + _displays.display[i].address);
					trace("export: " + src.nativePath + " > " + dst.nativePath);
					if (dst.exists) dst.moveToTrash();
					src.copyToAsync(dst, true);
					src.addEventListener(Event.COMPLETE, function(event:Event):void {
						trace("export done");
						Alert.show("エクスポートが完了しました");
					});
					src.addEventListener(IOErrorEvent.IO_ERROR, function(event:IOErrorEvent):void {
						trace("failex export I/O error ");
						Alert.show("エクスポート処理中に異常が発生しました");
					});
					Alert.show("エクスポートが終了したらダイアログでお知らせします.");
				});
				try {
					directory.browseForDirectory("エクスポート先のフォルダを選択してください。その下にswitch-datasフォルダが作成されます。");
				} catch (error:Error) {
					trace("Failed:", error.message);
				}
			} else {
				Alert.show("エクスポートしたいディスプレイを選択してください");
			}
		}

		/** 削除処理 */
		private final function deleteDisplayItem():void {
			var i:int = displayGrid.selectedIndex;
			if (i != -1) {
				var item:Object = displayGrid.selectedItem;
				Alert.show("ディスプレイ[" + item.name + "]を削除してよろしいですか？","アラート", Alert.YES | Alert.NO, this, function(event:CloseEvent):void {
					if (event.detail == Alert.YES) {
						var i:int = displayGrid.selectedIndex;
						if (i != -1) {
							trace("delete display: " + i);
							displayGrid.dataProvider.removeItemAt(i);
						}
					}
				});
			}
		}

		/** ディスプレイ情報保存 */
		private final function saveDisplay():void {
			trace('save displays');
			var displayFile:File = _workDir.resolvePath("displays.xml");
			SwitchUtils.saveXML(_displays, displayFile);
		}

		/** 編集開始 */
		private final function onDisplayEditBeginning(event:DataGridEvent):void {
			if (!validateDoubleClick(event)) {
				// シングルクリックの場合はイベントをキャンセル
				event.preventDefault();
			}
		}

		/** ダブルクリックか否かを判定します */
		private final function validateDoubleClick(event:DataGridEvent):Boolean {
			var result:Boolean = (
				_oldDataGridEvent != null && 
				event.columnIndex == _oldDataGridEvent.columnIndex &&
				event.rowIndex == _oldDataGridEvent.rowIndex
			);

			_oldDataGridEvent = (result)? null: event;
			return result;
		}


		/** 操作画面初期化 */
		private final function initPlayOperation():void {
			while (preview.getChildren().length > 0) {
				preview.removeChildAt(0);
			}
			var display:XML = getEditDisplay();
			if (display) {
				_workspace = <workspace />;
				unselectPlaylist();
				playlistSelector.dataProvider = null;
				mediaSelector.dataProvider = null;
				playlistEditor.dataProvider = null;
				scheduleEditor.dataProvider = null;
				shortcutList.dataProvider = null;

				if (isLocalMode()) {
					_editable = false;
					toggleEditMode(null);
					var display:XML = getEditDisplay();
					var fs:FileStream = new FileStream();
					try {
						var file:File = _workDir.resolvePath("datas/" + display.address.text() + "/workspace.xml");
						if (file.exists) {
							fs.open(file, FileMode.READ);
							var xml:String = fs.readUTFBytes(fs.bytesAvailable);
							_workspace = XML(xml);						
						} else {
							_workspace =
							<workspace>
							  <templates>
								<item id="t000" name="動画" type="movie">
								  <movie>%%1</movie>
								</item>
								<item duration="60000" id="t001" name="静止画" type="image">
								  <image>%%1</image>
								</item>
							  </templates>
							</workspace>;
						}
					} catch (error:Error) {
						trace("<Error> " + error.message);
					} finally {
						fs.close();		
					}
					startOperation(display);

				} else {
					_editable = true;
					toggleEditMode(null);
					var loader:URLLoader = new URLLoader();
					var request:URLRequest = new URLRequest(baseURL() + "/download?path=workspace.xml");
					request.cacheResponse = false;
					request.useCache = false;
					loader.addEventListener(Event.COMPLETE, function(event:Event):void {
						_signature = null;
						_workspace = new XML(event.target.data);
						var display:XML = getEditDisplay();
						if (display) {
							saveWorkspaceFile(display);
							startOperation(display);
							startPreview(); // 繋がった場合、プレビューの開始
							startStatus();
							if (!isMobile() && _workDir.exists) {
								if (!_mediaSyncronizer || !_mediaSyncronizer.running()) {
									_mediaSyncronizer = new MediaSyncronizer(_workDir, _displays, _workspace);
									_mediaSyncronizer.addEventListener(OperationStatusEvent.OPERATION_STATUS, function(event:OperationStatusEvent):void {
										updateStatusText(event.text);
									});
								}						
							} else {
								dispatchEvent(new OperationStatusEvent("操作オンリーモードで稼動"));
								editMode.enabled = false;
							}						
						}
					});
					loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:IOErrorEvent):void {
						trace(event);
						Alert.show("ワークスペースが読込めません.ディスプレイの設定を確認してください.");
					});
					loader.load(request);
				}				
			} else {
				Alert.show("ディスプレイの設定を確認してください.");				
				navigation.selectedIndex = 0;
			}
		}

		// 操作を開始する
		private final function startOperation(display:XML):void {
			playlistSelector.setData(_workspace);
			playlistSelector.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			mediaSelector.setData(_workDir, display.address.text(), _workspace);
			mediaSelector.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			playlistEditor.setData(_workspace);
			playlistEditor.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			scheduleEditor.setData(_workspace);
			scheduleEditor.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			shortcutList.setData(_workspace, baseURL(), setPlaylist);
			shortcutList.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			playlistSelector.dataProvider.addEventListener(CollectionEvent.COLLECTION_CHANGE, function(event:CollectionEvent):void {
				// editedWorkspace(event);
				shortcutList.dataProvider.refresh();
				scheduleEditor.dataProvider.refresh();
			});
			mediaSelector.dataProvider.addEventListener(CollectionEvent.COLLECTION_CHANGE, function(event:CollectionEvent):void {
				// editedWorkspace(event);
				if (playlistEditor.dataProvider) playlistEditor.dataProvider.refresh();
			});

			var loader:URLLoader = new URLLoader();
			loader.addEventListener(Event.COMPLETE, function(event:Event):void {
				var loader:URLLoader = URLLoader(event.currentTarget);
				var json:String = loader.data;
				try {
					var status:Object = JSON.decode(json);
					var fonts:Array = status['fonts'];
					mediaSelector.setFonts(fonts);
					trace('fonts: ' + fonts);
				} catch (error:Error) {
					trace(error.message + ":" + json);
				}
			});
			loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
			});
			var request:URLRequest = new URLRequest(baseURL() + "/get/fonts");
			request.cacheResponse = false;
			request.useCache = false;
			loader.load(request);
		}

		/** プレビューの開始 */
		private final function startPreview():void {
			if (!_previewTimer) {
				_previewTimer = new Timer(2000, 0);
				_previewTimer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
					var loader:Loader = new Loader();
					with (loader.contentLoaderInfo) {
						addEventListener(Event.COMPLETE, updatePreviewImage);
						addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
							trace("'/get/snapshot' no result");
							//event.target.loader.unload();
						});
					}
					var request:URLRequest = new URLRequest(baseURL() + "/get/snapshot");
					request.cacheResponse = false;
					request.useCache = false;
					loader.load(request);
				});
				_previewTimer.start();
			} else {
				_previewTimer.start();		
			}
		}

		/** プレビュー画像の更新 */
		private final function updatePreviewImage(event:Event):void {
			var image:Image = new Image();
			image.width = 240;
			image.height = 180;
			image.setStyle("horizontalAlign", "center");
			image.setStyle("verticalAlign", "center");
			image.setStyle("removedEffect", "Fade");			
			image.load(event.target.content); // イメージの更新
			preview.addChildAt(image, 0);
			event.target.loader.removeEventListener(Event.COMPLETE, updatePreviewImage);
			event.target.loader.unload();
			if (preview.getChildren().length >= 2) {
				preview.removeChildAt(1);
			}
		}

		/** プレビューの停止 */
		private final function stopPreview():void {
			if (_previewTimer) {
				_previewTimer.stop();
			}
			while (preview.getChildren().length > 0) {
				preview.removeChildAt(0);
			}			
		}

		/** ステータスモニタの開始 */
		private final function startStatus():void {
			if (!_statusTimer) {
				_statusTimer = new Timer(500, 0);
				_statusTimer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
					var loader:URLLoader = new URLLoader();
					loader.addEventListener(Event.COMPLETE, updateStatus);
					loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
						trace("'/get/status' no result");
						// event.target.loader.unload();
					});
					var request:URLRequest = new URLRequest(baseURL() + "/get/status");
					request.cacheResponse = false;
					request.useCache = false;
					loader.load(request);
				});
				_statusTimer.start();
			} else {
				_statusTimer.start();
			}
		}

		/** ステータスの更新 */
		private final function updateStatus(event:Event):void {
			var loader:URLLoader = URLLoader(event.currentTarget);
			loader.removeEventListener(Event.COMPLETE, updateStatus);
			if (_uploader) return;

			var json:String = loader.data;
			try {
				var status:Object = JSON.decode(json);
				_stageName = status['stage-name'];
				_currentPlaylist = SwitchUtils.parseJSONString(status['current-playlist']);
				_currentContent = SwitchUtils.parseJSONString(status['current-content']);
				_playingPlaylistID = SwitchUtils.parseJSONString(status['current-playlist-id']);
				var playlistIndex:String = SwitchUtils.parseJSONString(status['current-index']);
				if (playlistIndex && playlistIndex.length > 0) _playingIndex = parseInt(playlistIndex);
				_timeRemain = status['time_remain'];
				if (status['next-playlist'] != _currentPlaylist) {
					_nextPlaylist = SwitchUtils.parseJSONString(status['next-playlist']);
				} else {
					_nextPlaylist = '';
				}
				_nextContent = SwitchUtils.parseJSONString(status['next-content']);
				_preparedPlaylist = SwitchUtils.parseJSONString(status['prepared-playlist']);
				_preparedPlaylistID = SwitchUtils.parseJSONString(status['prepared-playlist-id']);
				_preparedContent = SwitchUtils.parseJSONString(status['prepared-content']);
				if (status['brightness']) _brightness = status['brightness'];
				if (_action != status['action']) {
					_action = status['action'];
					if (_action == 'stop') {
						action.selectedIndex = 1;
					} else if (_action == 'stop-prepared') {
						action.selectedIndex = 2;
					} else if (_action.indexOf("wait") != -1) {
						action.selectedIndex = 3;
					} else if (_action.indexOf("jump") != -1) {
						action.selectedIndex = 4;
					} else {
						action.selectedIndex = 0;
					}
				}
				if (_transition != status['transition']) {
					_transition = status['transition'];
					if (_transition == 'slide') {
						transition.selectedIndex = 1;
					} else if (_transition == 'dissolve') {
						transition.selectedIndex = 2;
					} else {
						transition.selectedIndex = 0;
					}
				}
				if (status['workspace']) {
					if (_signature == null) {
						_signature = status['workspace'];
						trace('workspace: ' + _signature);
					} else if (_signature != status['workspace']) {
						_signature = status['workspace'];
						if (_alert) PopUpManager.removePopUp(_alert);
						_alert = Alert.show("ワークスペースが更新されました");
					}
				}
				//if (status['set-text']) {
				//	var data:Array = status['set-text'].split(":", 2);
				//	var playlists:XMLList = _workspace.playlists.playlist.(@id == data[0]);
				//	for (var i:int = 0; i < playlists.length(); i++) {
				//		playlists[i].@text = data[1];
				//		trace(playlists[i].toXMLString());
				//	}
				//}

				updateSwitchButton();
			} catch (error:Error) {
				trace(error.message + ":" + json);
			}
		}

		/** ステータスモニタの停止 */
		private final function stopStatus():void {
			if (_statusTimer) {
				_statusTimer.stop();
			}
			_stageName = '';
			_currentPlaylist = '';
			_currentContent = '';
			_timeRemain = '';
			_nextPlaylist = '';
			_nextContent = '';
			_preparedPlaylist = '';
			_preparedContent = '';
			_signature = null;
		}


		/** 輝度変更 */
		private final function changeBrightness(event:Event):void {
			var request:URLRequest = new URLRequest(baseURL() + "/set/brightness");
			request.cacheResponse = false;
			request.useCache = false;
			request.method = URLRequestMethod.POST;
			var params:URLVariables = new URLVariables();
			params.v = brightness.value;
			request.data = params;
			sendToURL(request);
			trace("brightness: " + brightness.value);
		}


		/** ストップウォッチ */
		private final function actionStopWatch(event:Event):void {
			if (_stopWatchTimer == null) {
				_stopWatchTimer = new Timer(1000, 0);
				_stopWatchTimer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
					var now:Number = new Date().time;
					_watchElapsed += (now - _watchLast);
					_watchLast = now;
					var elapsed:int = _watchElapsed / 1000;
					watchTime.text = SwitchUtils.format(elapsed / 3600, 2) + ":" + SwitchUtils.format(elapsed / 60, 2) + ":" + SwitchUtils.format(elapsed % 60, 2);
				});
				_watchLast = new Date().time;
				_stopWatchTimer.start();
				watchButton.label = "停止";
			} else {
				_stopWatchTimer.stop();
				_stopWatchTimer = null;
				watchButton.label = "開始";
			}
		}

		/** ストップウォッチ リセット */
		private final function resetStopWatch():void {
			_watchElapsed = 0;
			watchTime.text = "00:00:00";
		}


		/** 編集モード変更 */
		private final function toggleEditMode(event:Event):void {
			if (_editable && _editedDisplay) {
				Alert.show("SAVEしないとロックできません");
				return;
			}
			_editable = !_editable;
			if (_editable) {
				editMode.setStyle("icon", _unlockIcon);
				//editMode.label = "○";
				//swButton.enabled = false;
				mediaTab.enabled = true;
				saveButton.visible = true;
				addPlaylistButton.enabled = true;
				deletePlaylistButton.enabled = true;
				addMediaButton.enabled = true;
				deleteMediaButton.enabled = true;
				//playlistSelector.dragEnabled = true;
				playlistSelector.dropEnabled = true; 
				mediaSelector.dragEnabled = true;
				if (playlistSelector.selectedIndex != -1) {
					colorPicker.enabled = true;
					playlistName.editable = true;
					playlistEditor.dragEnabled = true;
					deletePlaylistItemButton.enabled = true;
				}
				timelineTab.enabled = true;
				scheduleEditor.dragEnabled = true;
				addScheduleItemButton.enabled = true;
				deleteScheduleItemButton.enabled = true;

			} else {
				editMode.setStyle("icon", _lockIcon);
				// editMode.label = "×";
				//swButton.enabled = true;
				sourceTab.selectedIndex = 0;
				detailTab.selectedIndex = 0;
				mediaTab.enabled = false;
				if (!_editedDisplay) {
					saveButton.visible = false;
				}
				addPlaylistButton.enabled = false;
				deletePlaylistButton.enabled = false;
				addMediaButton.enabled = false;
				deleteMediaButton.enabled = false;
				//playlistSelector.dragEnabled = false;
				playlistSelector.dropEnabled = false; 
				mediaSelector.dragEnabled = false;
				colorPicker.enabled = false;
				playlistName.editable = false;
				playlistEditor.dragEnabled = false;
				deletePlaylistItemButton.enabled = false;
				timelineTab.enabled = false;
				scheduleEditor.dragEnabled = false;
				addScheduleItemButton.enabled = false;
				deleteScheduleItemButton.enabled = false;
			}
			updateSwitchButton();
		}

		private final function updateSwitchButton():void {
			if (_editable) {
				swButton.setStyle("fillColors", [0xe6eeee, 0xffffff]);
				swButton.enabled = false;

			} else {
				if ((_preparedContent != null && _preparedContent.length > 0) || (_nextContent != null && _nextContent.length > 0)) {
					swButton.setStyle("fillColors", [0x66e666, 0x66ff66]);
					swButton.enabled = true;
				} else {
					swButton.setStyle("fillColors", [0xe6eeee, 0xffffff]);
					swButton.enabled = false;
				}				
			}
		}

		/** プレイリスト変更 */
		public final function setPlaylist(id:String):void {
			var playlists:XMLList = _workspace.playlists.playlist.(@id == id);
			if (playlists.length() > 0) {
				_playlist = playlists[0];
				playlistEditor.dataProvider = _playlist.item;
				viewPlaylist();
			}
		}

		private final function changePlaylist():void {
			//trace("change playlist");
			if (playlistSelector.selectedItem) {
				_playlist = playlistSelector.selectedItem as XML;
				playlistEditor.dataProvider = _playlist.item;
			}
			viewPlaylist();
		}

		private final function viewPlaylist():void {
			if (_playlist.@color) {
				colorPicker.selectedColor = parseInt(_playlist.@color.toString(), 16);
			} else {
				colorPicker.selectedColor = 0x111111;		
			}
			playlistName.text = _playlist.@name;
			if (_editable) {
				colorPicker.enabled = true;
				playlistName.editable = true;
				playlistEditor.dragEnabled = true;
				deletePlaylistItemButton.enabled = true;
			}
			setTextEditMode();
			selectContent();
		}

		// テキストの編集可否を設定します
		private final function setTextEditMode():void {
			var useText:Boolean = false;
			var items:XMLList = _playlist.item;
			for (var i:int = 0; i < items.length(); i++) {
				var media:XMLList = _workspace.medialist.item.(@id == items[i].text());
				if (media.text.length() > 0) {
					useText = true;
					break;
				}
			}
			if (useText && !isLocalMode()) {
				var loader:URLLoader = new URLLoader();
				var request:URLRequest = new URLRequest(baseURL() + "/get/text?pl=" + _playlist.@id.toString());
				request.cacheResponse = false;
				request.useCache = false;
				loader.addEventListener(Event.COMPLETE, function(event:Event):void {
					var result:Object = JSON.decode(event.currentTarget.data);
					var text:String = result['text'];
					if (text && _playlist.@text != text) {
						playlistText.text = text;
						//_playlist.@text = text;						
					}
				});
				loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:IOErrorEvent):void {
					trace(event);
				});

				playlistName.text = _playlist.@name.toString();
				playlistName.horizontalScrollPosition = 0;
				if (_playlist.@text) {
					playlistText.text = _playlist.@text.toString();
				} else {
					playlistText.text = "";
				}
				playlistText.editable = true;
				textUpdateButton.visible = true;
				loader.load(request);
				
			} else {
				playlistText.text = "";
				playlistText.editable = false;
				textUpdateButton.visible = false;
			}
			//textUpdateButton.visible = false;
		}

		/** コンテンツ選択 */
		private final function selectContent():void {
			// trace("select content");
			if (!_editable) {
				var request:URLRequest = new URLRequest(baseURL() + "/set/playlist");
				request.cacheResponse = false;
				request.useCache = false;
				request.method = URLRequestMethod.POST;
				var params:URLVariables = new URLVariables();
				params.pl = _playlist.@id.toString();
				var i:int = playlistEditor.selectedIndex;
				params.i = (i == -1)?0:i;
				request.data = params;
				sendToURL(request);
				trace("set playlist: " + params.pl + "-" + params.i);				
			}
			
		}

		/** プレイリストの選択解除 */
		private final function unselectPlaylist():void {
			_playlist = <playlist />;
			colorPicker.selectedColor = 0x111111;		
			playlistName.text = "";
			colorPicker.enabled = false;
			playlistName.editable = false;
			playlistEditor.dragEnabled = false;
			playlistEditor.dataProvider = _playlist.item;
			deletePlaylistItemButton.enabled = false;
		}

		/** プレイリスト追加 */
		private final function addPlaylist(event:Event):void {
			var i:int = 0;
			var name:String = "新しいプレイリスト";
			while ((_workspace.playlists.playlist.(@name == name)).length() > 0) {
				i++;
				name = "新しいプレイリスト" + i;
			}
			trace("playlist name: " + name);

			var list:XML = <playlist />;
			list.@id = SwitchUtils.createNewID(_workspace.playlists.playlist, "pl");
			list.@name = name;
			var pos:int = playlistSelector.dataProvider.length;
			playlistSelector.dataProvider.addItemAt(list, pos);
			playlistSelector.selectedIndex = pos;
			changePlaylist();
			var t:Timer = new Timer(200, 1);
			t.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
				playlistSelector.scrollToIndex(playlistSelector.selectedIndex);
			});
			t.start();
			dispatchEvent(new EditedWorkspaceEvent());
		}

		/** プレイリスト削除 */
		private final function deletePlaylist(event:Event):void {
			var i:int = playlistSelector.selectedIndex;
			if (i != -1) {
				playlistSelector.dataProvider.removeItemAt(i);
				if (i > 0) playlistSelector.scrollToIndex(i - 1);
				unselectPlaylist();
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** プレイリスト名変更 */
		private final function changePlaylistName(event:Event):void {
			if (_editable && _playlist) {
				_playlist.@name = playlistName.text;
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** プレイリストカラー変更 */
		private final function changeColor(event:Event):void {
			if (_editable && _playlist) {
				_playlist.@color = colorPicker.selectedColor.toString(16);
				//playlistSelector.dataProvider.update();
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** プレイリストテキスト更新 */
		private final function updatePlaylistText(event:Event):void {
			trace("update playlist text");
			_playlist.@text = playlistText.text;

			var loader:URLLoader = new URLLoader();
			loader.addEventListener(Event.COMPLETE, function(event:Event):void {
				var loader:URLLoader = URLLoader(event.currentTarget);
				var json:String = loader.data;
				try {
					var result:Object = JSON.decode(json);
					if (result.text != null) {
						trace("text: " + result.text);
						selectContent();
						dispatchEvent(new EditedWorkspaceEvent());
					} else {
						Alert.show("not set playlist text!");						
					}
				} catch (error:Error) {
					trace(error.message + ":" + json);
				}
			});
			loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
				trace('remote display no result');
			});

			var request:URLRequest = new URLRequest(baseURL() + "/set/text");
			request.cacheResponse = false;
			request.useCache = false;
			request.method = URLRequestMethod.POST;
			var params:URLVariables = new URLVariables();
			params.pl = _playlist.@id.toString();
			params.t = playlistText.text;
			request.data = params;
			loader.load(request);
		}

		/** プレイリストアイテムの削除 */
		private final function deletePlaylistItem(event:Event):void {
			var i:int = playlistEditor.selectedIndex;
			if (i != -1) {
				if (i > 0) {
					playlistEditor.selectedIndex = i - 1;
				}
				playlistEditor.dataProvider.removeItemAt(i);
				if (i > 0) playlistEditor.scrollToIndex(i - 1);
				dispatchEvent(new EditedWorkspaceEvent());
			}
			setTextEditMode();
		}

		/** プレイリストのフィルタリング */
		private final function filterPlaylist(event:Event):void {
			trace("filter: " + findPlaylist.text);
			if (findPlaylist.text.length > 0) {
				var pattern:RegExp = new RegExp(findPlaylist.text, "i");
				playlistSelector.dataProvider.filterFunction = function(item:Object):Boolean {
					return pattern.test(item.@name.toString());
				}
			} else {
				playlistSelector.dataProvider.filterFunction = null;
			}
			playlistSelector.dataProvider.refresh();
		}

		/** メディア追加 */
		private final function addMedia(event:Event):void {
			var popup:IFlexDisplayObject = PopUpManager.createPopUp(Application.application as DisplayObject, MediaEditor, true);
			var editor:MediaEditor = popup as MediaEditor;
			editor.addEventListener(EditedWorkspaceEvent.EDITED, editedWorkspace);
			editor.selector = mediaSelector;
			//editor.workspace = _workspace;
			PopUpManager.centerPopUp(editor);
		}

		/** メディア削除 */
		private final function deleteMedia(event:Event):void {
			var i:int = mediaSelector.selectedIndex;
			if (i != -1) {
				var item:XML = mediaSelector.dataProvider.getItemAt(i);
				var xml:XMLList = _workspace.playlists.playlist.item.(text() == item.@id);
				if (xml.length() > 0) {
					Alert.show("プレイリストに登録されていますが削除しますか？", "削除の確認", Alert.YES | Alert.NO, this, function(event:CloseEvent):void {
						if (event.detail == Alert.YES) {
							var item:XML;
							for each(item in xml) {
								delete item.(true)[0];
							}
							if (_playlist) changePlaylist();
							mediaSelector.deleteSelectedItem();
							dispatchEvent(new EditedWorkspaceEvent());
						}
					});
					return;
				}
				mediaSelector.deleteSelectedItem();
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** メディアのフィルタリング */
		private final function filterMedia(event:Event):void {
			trace("filter: " + findMedia.text);
			if (findMedia.text.length > 0) {
				var pattern:RegExp = new RegExp(findMedia.text, "i");
				mediaSelector.dataProvider.filterFunction = function(item:Object):Boolean {
					return pattern.test(item.@name.toString());
				}				
			} else {
				mediaSelector.dataProvider.filterFunction = null;
			}
			mediaSelector.dataProvider.refresh();
		}

		/** 切替 */
		private final function switchContent():void {
			_returnPlaylistID = _playingPlaylistID;
			_returnIndex = _playingIndex;
			returnButton.enabled = true;
			trace("set return playlist " + _returnPlaylistID + "-" + _returnIndex);

			var loader:URLLoader = new URLLoader();
			loader.addEventListener(Event.COMPLETE, function(event:Event):void {
				var loader:URLLoader = URLLoader(event.currentTarget);
				var json:String = loader.data;
				try {
					var result:Object = JSON.decode(json);
					if (!result.switched) {
						Alert.show("not switched!");
					} else {
						var sl:Loader = new Loader();
						with (sl.contentLoaderInfo) {
							addEventListener(Event.COMPLETE, updatePreviewImage);
							addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
								trace('remote display no result');
								event.target.loader.unload();
							});
						}
						var request:URLRequest = new URLRequest(baseURL() + "/get/snapshot");
						request.cacheResponse = false;
						request.useCache = false;
						sl.load(request);
					}
				} catch (error:Error) {
					trace(error.message + ":" + json);
				}
			});
			loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
				trace('remote display no result');
			});
			swButton.enabled = false;
			var request:URLRequest = new URLRequest(baseURL() + "/switch");
			request.cacheResponse = false;
			request.useCache = false;
			loader.load(request);
		}

		/** スケジュールアイテムの追加 */
		private final function addScheduleItem(event:Event):void {
			var s:XML = <item />;
			s.@id = SwitchUtils.createNewID(_workspace.schedule.item, "sc");
			s.@time = "* * * 00 00 *";
			var pos:int = scheduleEditor.selectedIndex;
			if (pos == -1) {
				pos = scheduleEditor.dataProvider.length;
			}
			scheduleEditor.dataProvider.addItemAt(s, pos);
			scheduleEditor.selectedIndex = pos;
			scheduleEditor.scrollToIndex(pos);
			dispatchEvent(new EditedWorkspaceEvent());
		}

		/** スケジュールアイテムの削除 */
		private final function deleteScheduleItem(event:Event):void {
			var i:int = scheduleEditor.selectedIndex;
			if (i != -1) {
				scheduleEditor.dataProvider.removeItemAt(i);
				if (i > 0) scheduleEditor.scrollToIndex(i - 1);
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** ショートカットの削除 */
		private final function deleteShorcut(event:Event):void {
			var i:int = shortcutList.selectedIndex;
			if (i != -1) {
				if (i > 0) {
					shortcutList.selectedIndex = i - 1;
				}
				shortcutList.dataProvider.removeItemAt(i);
				dispatchEvent(new EditedWorkspaceEvent());
			}
		}

		/** プレイリストの復帰 */
		private final function returnPlaylist(event:Event):void  {
			var loader:URLLoader = new URLLoader();
			loader.addEventListener(Event.COMPLETE, function(event:Event):void {
				var loader:URLLoader = URLLoader(event.currentTarget);
				var json:String = loader.data;
				try {
					var result:Object = JSON.decode(json);
					if (!result.playlist) {
						Alert.show("not prepared playlist!");
					} else {
						trace("set playlist");
						var t:Timer = new Timer(500, 0);
						t.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
							trace("wait preparing");
							if (_returnPlaylistID != _preparedPlaylistID) {
								return;
							}
							t.stop();
							loader = new URLLoader();
							loader.addEventListener(Event.COMPLETE, function(event:Event):void {
								trace('do switch');
							});
							loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
								trace('failed error');
							});
							var request:URLRequest = new URLRequest(baseURL() + "/switch");
							request.cacheResponse = false;
							request.useCache = false;
							loader.load(request);
						});
						t.start();
					}
				} catch (error:Error) {
					trace(error.message + ":" + json);
				}
			});
			loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
				trace('remote display no result');
			});
			swButton.enabled = false;
			var request:URLRequest = new URLRequest(baseURL() + "/set/playlist");
			request.cacheResponse = false;
			request.useCache = false;
			request.method = URLRequestMethod.POST;
			var params:URLVariables = new URLVariables();
			params.pl = _returnPlaylistID;
			params.i = (_returnIndex < 0)?0: _returnIndex;
			request.data = params;
			loader.load(request);
		}

		/** ワークスペースの保存 */
		private final function saveWorkspaceFile(display:XML):File {
			if (!isMobile() && _workDir.exists && _workspace.deletes.length() > 0) {
				dispatchEvent(new OperationStatusEvent("不要ファイルの削除処理中..."));
				var items:XMLList = _workspace.medialist.item;
				var files:XMLList = _workspace.deletes.file;
				for (var i:int = 0; i < files.length(); i++) {
					var path:String = files[i].text();
					var datas:XMLList = items.image.(text() == path);
					datas += items.movie.(text() == path);
					if (datas.length() > 0) {
						delete files[i];
					} else {
						var name:String = files[i].text();
						if (name.indexOf("switch-data:") == 0) {
							name = name.substr(12);
						} else if (name.indexOf("http://") == 0) {
							continue;
						}
						var file:File = _workDir.resolvePath("datas/" + display.address + "/" + name);
						try {
							if (file && file.exists) {
								file.deleteFile();
								trace("delete: " + file.nativePath);
							}
						} catch (error:Error) {
						}						
					}
				}
			}

			var workspace:File = _workDir.resolvePath("datas/" + display.address.text() + "/workspace.xml");
			var fs:FileStream = new FileStream();
			try {
				fs.open(workspace, FileMode.WRITE);
				var s:String = '<?xml version="1.0" encoding="UTF-8" ?>\n'; 
				s += _workspace.toXMLString();
				fs.writeUTFBytes(s);
			} catch (error:Error) {
				trace("<Error> " + error.message);
			} finally {
				fs.close();
			}
			return workspace;
		}

		private final function saveWorkspace(event:Event):void {
			if (_uploader) {
				trace('already updating');
				return;
			}
			var display:XML = getEditDisplay();
			if (display) {
				var workspace:File = saveWorkspaceFile(display);
				var popup:IFlexDisplayObject = PopUpManager.createPopUp(Application.application as DisplayObject, UploadProgressBar, true);
				PopUpManager.centerPopUp(popup);
				_uploader = popup as UploadProgressBar;

				var files:Object = mediaSelector.getUploadFiles();
				for (var file:String in files) {
					var f:File = _workDir.resolvePath("datas/" + display.address + "/" + file);
					try {
						if (files[file].exists) {
							files[file].moveTo(f, true);
						} else if (!f.exists) {
						}
						_uploader.addFile(file, f);
					} catch (error:IOError) {
						trace(error.message);
					}
				}
				if (!isLocalMode()) {
					// 転送処理
					_uploader.addFile(workspace.name, workspace);
					_uploader.addEventListener(Event.COMPLETE, function(event:Event):void {
						//_signature = null;
						var loader:URLLoader = new URLLoader();
						loader.addEventListener(Event.COMPLETE, function(event:Event):void {
							trace("update complete");
							var loader:URLLoader = URLLoader(event.currentTarget);
							var json:String = loader.data;
							try {
								var result:Object = JSON.decode(json);
								if (!result.update) {
									_uploader.setMessage("保存に失敗しました");
								} else {
									//_signature = null;
									_signature = SwitchUtils.calculateMD5(workspace);
									mediaSelector.clearUploadFiles();
									PopUpManager.removePopUp(_uploader);
									uneditedWorkspace();
									dispatchEvent(new OperationStatusEvent("保存しました"));
									copyWorkspace();
								}
							} catch (error:Error) {
								trace(error.message + ":" + json);
							}
							_uploader = null;
						});
						loader.addEventListener(IOErrorEvent.IO_ERROR, function(event:Event):void {
							trace('remote display no result');
							_uploader = null;
						});
						var request:URLRequest = new URLRequest(baseURL() + "/update");
						request.cacheResponse = false;
						request.useCache = false;
						loader.load(request);
					});
					_uploader.addEventListener(UpdatedWorkspaceEvent.COMPLETE, function(event:Event):void {
						trace('update finished');
						_uploader = null;
					});
					_uploader.startUpload(baseURL());

				} else {
					mediaSelector.clearUploadFiles();
					PopUpManager.removePopUp(_uploader);
					_uploader = null;
					uneditedWorkspace();
					Alert.show("ローカル保存を行いました");
				}
			}
		}

		private final function copyWorkspace():void {
			if (_displays) {
				var edit:String = "";
				var outDisplays:Array = new Array();
				for (var i:int = 0; i < _displays.display.length(); i++) {
					if (_displays.display[i].edit == 'true') {
						edit = _displays.display[i].address;
					}
					if (_displays.display[i].out == 'true') {
						outDisplays.push(_displays.display[i].address);
					}
				}
				while (outDisplays.length > 0) {
					var out:String = outDisplays.shift();
					if (out != edit) {
						dispatchEvent(new OperationStatusEvent(" "));
						var request:URLRequest = new URLRequest(SwitchUtils.baseURL(out) + "/copy");
						request.cacheResponse = false;
						request.useCache = false;
						request.method = URLRequestMethod.POST;
						var params:URLVariables = new URLVariables();
						params.remote = SwitchUtils.baseURL(edit);
						request.data = params;
						sendToURL(request);
						trace("remote copy: " + edit + " > " + out);
					}
				}
			}
		}

		/** 閉じる */
		private final function onClose():void {
			var text:String;
			if (_editedDisplay) {
				text = "変更されていますが、保存せずに終了してよろしいですか？";
			} else {
				text = "終了してよろしいですか？";
			}

			// 終了を確認
			Alert.show(text, "終了の確認", Alert.YES | Alert.NO, this, function(event:CloseEvent):void {
				if (event.detail == Alert.YES) {
					saveDisplay();
					stage.nativeWindow.close();
				}
			});
		}

		private final function isMobile():Boolean {
			return Capabilities.os.indexOf("linux") != -1;
		}
	]]></mx:Script>
</mx:Application>
